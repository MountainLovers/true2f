/*
 * Copyright (c) 2018, Google Inc.
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <gtest/gtest.h>

#include "src/common.h"
#include "src/params.h"
#include "src/sanitizable_ecdsa.h"

/* Test that correctly generated signature and proof are accepted. */
TEST(SanitizableECDSA, Basic) {
  int rv;
  Params params = NULL;
  BIGNUM *sk = NULL;
  EC_POINT *vk = NULL;
  ECDSA_SIG *sig = NULL;
  PedersenEvidence ev = NULL;
  PedersenStatement st = NULL;
  const uint8_t message[] = "foo";

  CHECK_A (params = Params_new(P256));
  CHECK_A (sk = BN_new());
  CHECK_A (vk = Params_point_new(params));
  CHECK_A (sig = ECDSA_SIG_new());
  CHECK_A (ev = PedersenEvidence_new(params));
  CHECK_A (st = PedersenStatement_new());

  // Generate keypair.
  EXPECT_EQ (SanitizableEcdsa_keygen(params, sk, vk), OKAY);
  // Sign.
  EXPECT_EQ (SanitizableEcdsa_sign(params, message, sizeof(message), sk, sig,
                                   st, ev), OKAY);
  // Verify signature.
  EXPECT_EQ (SanitizableEcdsa_verify(params, message, sizeof(message), vk, sig,
                                     st, ev), OKAY);

cleanup:
  if (params) Params_free(params);
  if (sk) BN_clear_free(sk);
  if (vk) EC_POINT_clear_free(vk);
  if (sig) ECDSA_SIG_free(sig);
  if (ev) PedersenEvidence_free(ev);
  if (st) PedersenStatement_free(st);
  EXPECT_TRUE (rv == OKAY);
}

/* Test that signature and proof generated from bad keypair are not accepted. */
TEST(SanitizableECDSA, BadKeypair) {
  int rv;
  Params params = NULL;
  BIGNUM *sk = NULL;
  EC_POINT *vk = NULL;
  ECDSA_SIG *sig = NULL;
  PedersenEvidence ev = NULL;
  PedersenStatement st = NULL;
  const uint8_t message[] = "foo";

  CHECK_A (params = Params_new(P256));
  CHECK_A (sk = BN_new());
  CHECK_A (vk = Params_point_new(params));
  CHECK_A (sig = ECDSA_SIG_new());
  CHECK_A (ev = PedersenEvidence_new(params));
  CHECK_A (st = PedersenStatement_new());

  // Generate bad keypair.
  EXPECT_EQ (Params_rand_exponent(params, sk), OKAY);
  EXPECT_EQ (Params_rand_point(params, vk), OKAY);
  // Sign.
  EXPECT_EQ (SanitizableEcdsa_sign(params, message, sizeof(message), sk, sig,
                                   st, ev), OKAY);
  // Verify signature.
  EXPECT_EQ (SanitizableEcdsa_verify(params, message, sizeof(message), vk, sig,
                                     st, ev), ERROR);

cleanup:
  if (params) Params_free(params);
  if (sk) BN_clear_free(sk);
  if (vk) EC_POINT_clear_free(vk);
  if (sig) ECDSA_SIG_free(sig);
  if (ev) PedersenEvidence_free(ev);
  if (st) PedersenStatement_free(st);
  EXPECT_TRUE (rv == OKAY);
}

/* Test that correctly generated signature and proof are accepted. Note that no
 * test for checking if a signature generated by ECDSA_sign is accepted by
 * SanitizableEcdsa_verify is included because only a subset of ECDSA signatures
 * are accepted by SanitizableEcdsa_Verify (only (r,s) and not (r,-s)).*/
TEST(SanitizableECDSA, CompatibleSign) {
  int rv;
  Params params = NULL;
  BIGNUM *sk = NULL;
  EC_POINT *vk = NULL;
  ECDSA_SIG *sig = NULL;
  PedersenEvidence ev = NULL;
  PedersenStatement st = NULL;
  const uint8_t message[] = "foo";
  EC_KEY *ec_vk = NULL;
  size_t m_buf_len;
  uint8_t *m_buf = NULL;

  CHECK_A (params = Params_new(P256));
  CHECK_A (sk = BN_new());
  CHECK_A (vk = Params_point_new(params));
  CHECK_A (sig = ECDSA_SIG_new());
  CHECK_A (ev = PedersenEvidence_new(params));
  CHECK_A (st = PedersenStatement_new());
  CHECK_A (ec_vk = EC_KEY_new());

  // Generate keypair.
  EXPECT_EQ (SanitizableEcdsa_keygen(params, sk, vk), OKAY);
  // Sign.
  EXPECT_EQ (SanitizableEcdsa_sign(params, message, sizeof(message), sk, sig,
                                   st, ev), OKAY);
  // Verify signature using standard ECDSA verification.
  CHECK_C (EC_KEY_set_group(ec_vk, Params_group(params)));
  CHECK_C (EC_KEY_set_public_key(ec_vk, vk));
  m_buf_len = BN_num_bytes(Params_order(params));
  CHECK_A (m_buf = (uint8_t *)malloc(m_buf_len));
  CHECK_C (hash_to_bytes(m_buf, m_buf_len, message, sizeof(message)));
  EXPECT_EQ (ECDSA_do_verify(m_buf, m_buf_len, sig, ec_vk), OKAY);

cleanup:
  if (params) Params_free(params);
  if (sk) BN_clear_free(sk);
  if (vk) EC_POINT_clear_free(vk);
  if (sig) ECDSA_SIG_free(sig);
  if (ev) PedersenEvidence_free(ev);
  if (st) PedersenStatement_free(st);
  if (ec_vk) EC_KEY_free(ec_vk);
  if (m_buf) free(m_buf);
  EXPECT_TRUE (rv == OKAY);
}
